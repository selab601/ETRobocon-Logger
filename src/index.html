<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>ET2016 EV3 Logger</title>

    <style>
      .axis path,
      .axis line {
        fill: none;
        stroke: black;
        shape-rendering: crispEdges;
      }

      .axis text {
        font-family: sans-serif;
        font-size: 11px;
      }
    </style>

    <!-- ライブラリのロード -->
    <script>
      window.jQuery = window.$ = require('./js/lib/jquery-3.1.0.min.js');
      var d3 = require('./js/lib/d3.min.js');
    </script>

    <script>
      "use strict";

      var initialized = false;

      // 各種設定値
      const stageHeight = 400;
      const stageWidth = 700;
      const padding = 40;
      const graphHeight = stageHeight - padding*2;
      const graphWidth = stageWidth - padding*2;

      // 設定値．受け取る値を変更した場合はここに追加していく
      // TODO: 最大値，最小値は更新する
      var configMap = {
        "color_brightness": {
          idName: "color_brightness",
          maxYData: 80,
          minYData: 0,
        },
        "gyro": {
          idName: "gyro",
          maxYData: 500,
          minYData: -500,
        }
      };
      var stateMap = {};

      // DOM の準備ができたら初期化処理を行う
      $(document).ready(function() {
        Object.keys(configMap).forEach(function(key) {
          // stateMapを初期化
          var value = this[key];
          stateMap[key] = {
            values: []
          };

          // SVG要素をDOMに追加
          d3.select("#d3graph")
            .append("svg")
            .attr('class', 'chart')
            .attr('id', configMap[key].idName)
            .attr("width", stageWidth)
            .attr("height", stageHeight);
        }, configMap);

        initialized = true;
      });

      // EV3 から格値を受け取る
      var ipcRenderer = require('electron').ipcRenderer;
      ipcRenderer.on('serial', (ev, message) => {
        var data = JSON.parse(message);

        if (initialized) {
          // 値の更新
          update("color_brightness", data.color.brightness);
          update("gyro", data.gyro);

          // 描画
          renderDynamicGraph("color_brightness" );
          renderDynamicGraph("gyro");
        }
      });

      var update = function (key, value) {
        // TODO: データが入り過ぎるとやばそうなのでどうにかする
        stateMap[key].values.push(value);
      }

      // リアルタイムにグラフを表示する
      // @param key 描画したい要素のキー
      // @param 最新の値からどの範囲までを描画するか
      var renderDynamicGraph = function (key, size) {
        var stage = d3.select("svg#"+configMap[key].idName);
        var maxXData = size == null ? 100 : size;
        var minXData = 0;
        var xScale = d3.scale.linear()
                       .range([padding, stageWidth - padding])
                       .domain([minXData, maxXData]);
        var yScale = d3.scale.linear()
                       .range([stageHeight - padding, padding])
                       .domain([configMap[key].minYData, configMap[key].maxYData]);
        var xAxis = d3.svg.axis()
                      .scale(xScale)
                      .orient('bottom');
        var yAxis = d3.svg.axis()
                      .scale(yScale)
                      .orient('left');
        var line = d3.svg.line()
                     .x(function(d,i){return xScale(i);})
                     .y(function(d,i){return yScale(d);})
                     .interpolate("linear");

        // TODO: slice は効率が悪いかも？
        var len = stateMap[key].values.length;
        var shownValues = stateMap[key].values.slice(
          len < 100 ? 0 : len - 100,
          len
        );

        // グラフの再描画
        stage.selectAll("path#"+configMap[key].idName).remove();
        stage.append("path")
             .attr("id", configMap[key].idName)
             .attr("d", line(shownValues))
             .attr("stroke", "steelblue")
             .attr("fill", "none");

        // ラベルの再描画
        stage.selectAll("text").remove();
        stage.selectAll("text")
             .data(shownValues)
             .enter()
             .append("text")
             .text(function(d) { return d; })
             .attr("x", function(d, i) {
               return padding + ( graphWidth / 100 ) * i;
             })
             .attr("y", function(d) {
               return padding + graphHeight
                    - ( graphHeight / ( configMap[key].maxYData - configMap[key].minYData ) )
                    * ( d - configMap[key].minYData );
             })
             .attr("font-family", "sans-serif")
             .attr("font-size", "11px")
             .attr("fill", "black");

        // 軸の再描画
        // TODO: X軸を時刻にしたい
        stage.selectAll("g").remove();
        stage.append('g')
             .attr("class", "axis")
             .attr("transform", "translate(0," + ( stageHeight - padding ) + ")")
             .call(xAxis);
        stage.append('g')
             .attr("class", "axis")
             .attr("transform", "translate(" + padding + ",0)")
             .call(yAxis);
      };

    </script>
  </head>
  <body>
    <div id="d3graph"></div>
  </body>
</html>
