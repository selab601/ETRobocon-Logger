<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>ET2016 EV3 Logger</title>

    <style>
      .axis path,
      .axis line {
        fill: none;
        stroke: black;
        shape-rendering: crispEdges;
      }

      .axis text {
        font-family: sans-serif;
        font-size: 11px;
      }
    </style>

    <!-- ライブラリのロード -->
    <script>
      window.jQuery = window.$ = require('./js/lib/jquery-3.1.0.min.js');
      var d3 = require('./js/lib/d3.min.js');
    </script>

    <script>
      "use strict";

      var initialized = false;

      // 各種設定値
      const stageHeight = 400;
      const stageWidth = 700;
      const padding = 40;
      const graphHeight = stageHeight - padding*2;
      const graphWidth = stageWidth - padding*2;

      var configMap = {
        "color_brightness": {
          idName: "color_brightness",
          maxXData: 100,
          minXData: 0,
          maxYData: 80,
          minYData: 0,
        },
        "gyro": {
          idName: "gyro",
          maxXData: 100,
          minXData: 0,
          maxYData: 500,
          minYData: -500,
        }
      };

      var stateMap = {
        "color_brightness": {
          xShift: 0,
          values: []
        },
        "gyro": {
          xShift: 0,
          values: []
        }
      };

      // DOM の準備ができたら描画する
      $(document).ready(function() {
        // SVG要素をDOMに追加
        d3.select("#d3graph")
          .append("svg")
          .attr('class', 'chart')
          .attr('id', 'color_brightness')
          .attr("width", stageWidth)
          .attr("height", stageHeight);
        d3.select("#d3graph")
          .append("svg")
          .attr('class', 'chart')
          .attr('id', 'gyro')
          .attr("width", stageWidth)
          .attr("height", stageHeight);

        initialized = true;
      });

      // EV3 から格値を受け取る
      var ipcRenderer = require('electron').ipcRenderer;
      ipcRenderer.on('serial', (ev, message) => {
        var data = JSON.parse(message);

        if (initialized) {
          update("color_brightness", data.color.brightness);
          update("gyro", data.gyro);

          renderGraph("color_brightness" );
          renderGraph("gyro");
        }
      });

      var update = function (key, value) {
        stateMap[key].values.push(value);
        if(stateMap[key].values.length > configMap[key].maxXData) {
          // データが入り過ぎるとやばい(かもしれない)のでどうにかする
          // configMap[key].values.shift();
          stateMap[key].xShift++;
        }
      }

      var renderGraph = function (key) {
        var stage = d3.select("svg#"+configMap[key].idName);
        var xScale = d3.scale.linear()
                       .range([padding, stageWidth - padding])
                       .domain([configMap[key].minXData, configMap[key].maxXData]);
        var xAxis = d3.svg.axis()
                      .scale(xScale)
                      .orient('bottom');
        var yScale = d3.scale.linear()
                       .range([stageHeight - padding, padding])
                       .domain([configMap[key].minYData, configMap[key].maxYData]);
        var yAxis = d3.svg.axis()
                      .scale(yScale)
                      .orient('left');
        var line = d3.svg.line()
                     .x(function(d,i){return xScale(i);})
                     .y(function(d,i){return yScale(d);})
                     .interpolate("linear");

        // TODO: slice は効率が悪いかも？
        var shownValues = stateMap[key].values.slice(
          stateMap[key].xShift,
          stateMap[key].xShift + 100
        );

        // グラフの再描画
        stage.selectAll("path#"+configMap[key].idName).remove();
        stage.append("path")
             .attr("id", configMap[key].idName)
             .attr("d", line(shownValues))
             .attr("stroke", "steelblue")
             .attr("fill", "none");

        // ラベルの再描画
        stage.selectAll("text").remove();
        stage.selectAll("text")
             .data(shownValues)
             .enter()
             .append("text")
             .text(function(d) { return d; })
             .attr("x", function(d, i) {
               return padding + ( graphWidth / 100 ) * i;
             })
             .attr("y", function(d) {
               return padding + graphHeight
                    - ( graphHeight / ( configMap[key].maxYData - configMap[key].minYData ) )
                    * ( d - configMap[key].minYData );
             })
             .attr("font-family", "sans-serif")
             .attr("font-size", "11px")
             .attr("fill", "black");

        // 軸の再描画
        stage.selectAll("g").remove();
        stage.append('g')
             .attr("class", "axis")
             .attr("transform", "translate(0," + ( stageHeight - padding ) + ")")
             .call(xAxis);
        stage.append('g')
             .attr("class", "axis")
             .attr("transform", "translate(" + padding + ",0)")
             .call(yAxis);
      };

    </script>
  </head>
  <body>
    <div id="d3graph"></div>
  </body>
</html>
