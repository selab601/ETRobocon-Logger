<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>ET2016 EV3 Logger</title>

    <style>
      .axis path,
      .axis line {
        fill: none;
        stroke: black;
        shape-rendering: crispEdges;
      }

      .axis text {
        font-family: sans-serif;
        font-size: 11px;
      }
    </style>

    <!-- ライブラリのロード -->
    <script>
      window.jQuery = window.$ = require('./js/lib/jquery-3.1.0.min.js');
      var d3 = require('./js/lib/d3.min.js');
    </script>

    <script>
      "use strict";

      // ----------------- ログをファイルに保存 ----------------
      require('date-utils');
      var LogWriter = function(){
        this.date = new Date();
        this.formatted = this.date.toFormat("YYYY_MMDD_HH24MISS");
        this.fileName = 'log/' + this.formatted + '.json';
        this.file = require('fs');

        // HTMLにファイル名を表示
        this.element = document.createElement('div');
        this.element.innerHTML = '<h2>Log File: ' + this.fileName  + '</h2>';
        document.getElementsByTagName("body").item(0).appendChild(this.element);
      }

      LogWriter.prototype.append = function(message){
        // ファイルに書き込む
        this.file.appendFile(this.fileName, message ,'utf8' );
      }

      var logWriter;
      // --------------------------------------------------------

      var initialized = false;

      // 各種設定値
      const stageHeight = 500;
      const stageWidth = 1000;
      const titleSpace = 20;
      const paddingLeft = 40;
      const paddingRight = 10;
      const paddingTop = 10;
      const paddingBottom = 40;
      const graphHeight = stageHeight - (paddingTop+paddingBottom) - titleSpace;
      const graphWidth = stageWidth - (paddingLeft+paddingRight);

      // 設定値．受け取る値を変更した場合はここに追加していく
      // TODO: 最大値，最小値は更新する
      var receiveValues = {
        "clock": {},
        "gyro": {},
        "touch": {},
        "sonar": {},
        "brightness": {},
        "rgb_r": {},
        "rgb_g": {},
        "rgb_b": {},
        "hsv_h": {},
        "hsv_s": {},
        "hsv_v": {},
        "arm_count": {},
        "left_count": {},
        "right_count": {},
        "length": {},
        "angle": {},
        "coordinate_x": {},
        "coordinate_y": {}
      };

      // EV3 から格値を受け取る
      var ipcRenderer = require('electron').ipcRenderer;
      ipcRenderer.on('serial', (ev, message) => {
        var data = JSON.parse(message);

        // ログの保存
        logWriter.append(message);

        if (initialized) {
          // 値の更新
          Object.keys(receiveValues).forEach(function(key) {
            update(key, data[key])
          }, receiveValues);

          // 描画
          // 全てのグラフを描画しようとするとめちゃくちゃ重くなるので注意
          /*
          Object.keys(receiveValues).forEach(function(key) {
            var value = this[key];
            renderDynamicGraph(key);
          }, receiveValues);
          */
          renderDynamicGraph("brightness");
        }
      });

      // DOM の準備ができたら初期化処理を行う
      $(document).ready(function() {
        Object.keys(receiveValues).forEach(function(key) {
          // 受信した値の履歴を初期化
          receiveValues[key].history = [];

          // SVG要素をDOMに追加
          /*d3.select("#d3graph")
            .append("svg")
            .attr('class', 'chart')
            .attr('id', key)
            .attr("width", stageWidth)
             .attr("height", stageHeight);*/
        }, receiveValues);

        d3.select("#d3graph")
          .append("svg")
          .attr('class', 'chart')
          .attr('id', "brightness")
          .attr("width", stageWidth)
          .attr("height", stageHeight);

        logWriter = new LogWriter();

        initialized = true;
      });

      var update = function (key, value) {
        // TODO: データが入り過ぎるとやばそうなのでどうにかする
        receiveValues[key].history.push(value);
      }

      // リアルタイムにグラフを表示する
      // @param key 描画したい要素のキー
      // @param 最新の値からどの範囲までを描画するか
      // @param グラフのY軸の描画範囲として，値の取りうる最大値，最小値を設定
      var renderDynamicGraph = function (key, size, yScope) {
        var stage = d3.select("svg#"+key);
        var maxXData = size == null ? 100 : size;
        var minXData = 0;
        // 動的にY軸の描画範囲を変更する場合は，上限と下限を大きめ/小さめに設定する
        // こうしないと，minYData == maxYData ( minYData - maxYData == 0 ) となり，後の計算式で0除算を引き起こす
        var yMargin = 10;
        var maxYData = yScope != null ? yScope[1] : Math.max.apply(null, receiveValues[key].history) + yMargin;
        var minYData = yScope != null ? yScope[0] : Math.min.apply(null, receiveValues[key].history) - yMargin;
        var xScale = d3.scale.linear()
                       .range([paddingLeft, stageWidth - paddingRight])
                       .domain([minXData, maxXData]);
        var yScale = d3.scale.linear()
                       .range([stageHeight - paddingBottom, paddingTop + titleSpace])
                       .domain([minYData, maxYData]);
        var xAxis = d3.svg.axis()
                      .scale(xScale)
                      .orient('bottom');
        var yAxis = d3.svg.axis()
                      .scale(yScale)
                      .orient('left');
        var line = d3.svg.line()
                     .x(function(d,i){return xScale(i);})
                     .y(function(d,i){return yScale(d);})
                     .interpolate("linear");

        // TODO: slice は効率が悪いかも？
        var len = receiveValues[key].history.length;
        var shownValues = receiveValues[key].history.slice(
          len < 100 ? 0 : len - 100,
          len
        );

        // グラフの再描画
        stage.selectAll("path#"+key).remove();
        stage.append("path")
             .attr("id", key)
             .attr("d", line(shownValues))
             .attr("stroke", "steelblue")
             .attr("fill", "none");

        // ラベルとグラフタイトルの再描画
        stage.selectAll("text").remove();
        stage.selectAll("text")
             .data(shownValues)
             .enter()
             .append("text")
             .text(function(d) { return d; })
             .attr("x", function(d, i) {
               return paddingLeft + ( graphWidth / 100 ) * i;
             })
             .attr("y", function(d) {
               return paddingTop + titleSpace + graphHeight
                    - ( graphHeight / ( maxYData - minYData ) )
                    * ( d - minYData );
             })
             .attr("font-family", "sans-serif")
             .attr("font-size", "11px")
             .attr("fill", "black");
        stage.append("text")
             .attr("x", paddingLeft)
             .attr("y", titleSpace)
             .text(key)
             .attr("font-family", "sans-serif")
             .attr("font-size", "16px")
             .attr("fill", "black");

        // 軸の再描画
        // TODO: X軸を時刻にしたい
        stage.selectAll("g").remove();
        stage.append('g')
             .attr("class", "axis")
             .attr("transform", "translate(0," + ( stageHeight - paddingBottom ) + ")")
             .call(xAxis);
        stage.append('g')
             .attr("class", "axis")
             .attr("transform", "translate(" + paddingLeft + ",0)")
             .call(yAxis);
      };

    </script>
  </head>
  <body>
    <div id="d3graph"></div>
  </body>
</html>
