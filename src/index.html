<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>ET2016 EV3 Logger</title>

    <style>
      .axis path,
      .axis line {
        fill: none;
        stroke: black;
        shape-rendering: crispEdges;
      }

      .axis text {
        font-family: sans-serif;
        font-size: 11px;
      }
    </style>

    <!-- ライブラリのロード -->
    <script>
      window.jQuery = window.$ = require('./js/lib/jquery-3.1.0.min.js');
      var d3 = require('./js/lib/d3.min.js');
    </script>

    <script>
      var initialized = false;

      // 各種設定値
      var stageHeight = 400;
      var stageWidth = 700;
      var padding = 40;
      var graphHeight = stageHeight - padding*2;
      var graphWidth = stageWidth - padding*2;
      var points = new Array();

      var configMap = {
        "color_brightness": {
          idName: "color_brightness",
          maxXData: 100,
          minXData: 0,
          maxYData: 80,
          minYData: 0,
        },
        "gyro": {
          idName: "gyro",
          maxXData: 100,
          minXData: 0,
          maxYData: 500,
          minYData: -500,
        }
      };

      var stateMap = {
        "color_brightness": {
          xShift: 0,
          values: []
        },
        "gyro": {
          xShift: 0,
          values: []
        }
      };

      // DOM の準備ができたら描画する
      $(document).ready(function() {
        // SVG要素をDOMに追加
        d3.select("#d3graph")
          .append("svg")
          .attr('class', 'chart')
          .attr('id', 'color_brightness')
          .attr("width", stageWidth)
          .attr("height", stageHeight);
        d3.select("#d3graph")
          .append("svg")
          .attr('class', 'chart')
          .attr('id', 'gyro')
          .attr("width", stageWidth)
          .attr("height", stageHeight);

        initialized = true;
      });

      var renderGraph = function (dataKey, dataValue) {
        var stage = d3.select("svg#"+configMap[dataKey].idName);

        var xScale = d3.scale.linear()
                       .range([padding, stageWidth - padding])
                       .domain([
                         configMap[dataKey].minXData,
                         configMap[dataKey].maxXData
                       ]);
        var xAxis = d3.svg.axis()
                      .scale(xScale)
                      .orient('bottom');
        var yScale = d3.scale.linear()
                       .range([stageHeight - padding, padding])
                       .domain([
                         configMap[dataKey].minYData,
                         configMap[dataKey].maxYData
                       ]);
        var yAxis = d3.svg.axis()
                      .scale(yScale)
                      .orient('left');
        var line = d3.svg.line()
                     .x(function(d,i){return xScale(i);})
                     .y(function(d,i){return yScale(d);})
                     .interpolate("linear");

        // データの更新
        stateMap[dataKey].values.push(dataValue);
        if(stateMap[dataKey].values.length > configMap[dataKey].maxXData) {
          // データが入り過ぎるとやばい(かもしれない)のでどうにかする
          // configMap[dataKey].values.shift();
          stateMap[dataKey].xShift++;
        }

        // TODO: slice は効率が悪いかも？
        var shownValues = stateMap[dataKey].values.slice(
          stateMap[dataKey].xShift,
          stateMap[dataKey].xShift + 100
        );

        // グラフの再描画
        stage.selectAll("path#"+configMap[dataKey].idName).remove();
        stage.append("path")
             .attr("id", configMap[dataKey].idName)
             .attr("d", line(shownValues))
             .attr("stroke", "steelblue")
             .attr("fill", "none");

        // ラベルの再描画
        stage.selectAll("text").remove();
        stage.selectAll("text")
             .data(shownValues)
             .enter()
             .append("text")
             .text(function(d) { return d; })
             .attr("x", function(d, i) {
               return padding + ( graphWidth / 100 ) * i;
             })
             .attr("y", function(d) {
               return padding + graphHeight - ( graphHeight / ( configMap[dataKey].maxYData - configMap[dataKey].minYData ) ) * ( d - configMap[dataKey].minYData );
             })
             .attr("font-family", "sans-serif")
             .attr("font-size", "11px")
             .attr("fill", "black");

        // 軸の再描画
        stage.selectAll("g").remove();
        stage.append('g')
             .attr("class", "axis")
             .attr("transform", "translate(0," + ( stageHeight - padding ) + ")")
             .call(xAxis);
        stage.append('g')
             .attr("class", "axis")
             .attr("transform", "translate(" + padding + ",0)")
             .call(yAxis);
      };

      // EV3 から格値を受け取る
      var ipcRenderer = require('electron').ipcRenderer;
      ipcRenderer.on('serial', (ev, message) => {
        var data = JSON.parse(message);

        if (initialized) {
          renderGraph("color_brightness", data.color.brightness);
          renderGraph("gyro", data.gyro);
        }
      });
    </script>
  </head>
  <body>
    <div id="d3graph"></div>
  </body>
</html>
